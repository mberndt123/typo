/**
 * File has been automatically generated by `typo` for internal use.
 *
 * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
 *
 * (If you're developing `typo` and want to change it: run `bleep generate-sources`)
 */
package typo
package generated
package information_schema
package columns

import anorm.NamedParameter
import anorm.ParameterValue
import anorm.SqlStringInterpolation
import java.sql.Connection

object ColumnsViewRepoImpl extends ColumnsViewRepo {
  override def selectAll(implicit c: Connection): List[ColumnsViewRow] = {
    SQL"""select table_catalog, table_schema, "table_name", "column_name", ordinal_position, column_default, is_nullable, data_type, character_maximum_length, character_octet_length, numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision, "character_set_catalog", "character_set_schema", "character_set_name", "collation_catalog", "collation_schema", "collation_name", domain_catalog, domain_schema, domain_name, udt_catalog, udt_schema, udt_name, "scope_catalog", "scope_schema", "scope_name", maximum_cardinality, dtd_identifier, is_self_referencing, is_identity, identity_generation, identity_start, identity_increment, identity_maximum, identity_minimum, identity_cycle, is_generated, generation_expression, is_updatable
          from information_schema."columns"
       """.as(ColumnsViewRow.rowParser(1).*)
  }
  override def selectByFieldValues(fieldValues: List[ColumnsViewFieldOrIdValue[_]])(implicit c: Connection): List[ColumnsViewRow] = {
    fieldValues match {
      case Nil => selectAll
      case nonEmpty =>
        val namedParams = nonEmpty.map{
          case ColumnsViewFieldValue.tableCatalog(value) => NamedParameter("table_catalog", ParameterValue.from(value))
          case ColumnsViewFieldValue.tableSchema(value) => NamedParameter("table_schema", ParameterValue.from(value))
          case ColumnsViewFieldValue.tableName(value) => NamedParameter("table_name", ParameterValue.from(value))
          case ColumnsViewFieldValue.columnName(value) => NamedParameter("column_name", ParameterValue.from(value))
          case ColumnsViewFieldValue.ordinalPosition(value) => NamedParameter("ordinal_position", ParameterValue.from(value))
          case ColumnsViewFieldValue.columnDefault(value) => NamedParameter("column_default", ParameterValue.from(value))
          case ColumnsViewFieldValue.isNullable(value) => NamedParameter("is_nullable", ParameterValue.from(value))
          case ColumnsViewFieldValue.dataType(value) => NamedParameter("data_type", ParameterValue.from(value))
          case ColumnsViewFieldValue.characterMaximumLength(value) => NamedParameter("character_maximum_length", ParameterValue.from(value))
          case ColumnsViewFieldValue.characterOctetLength(value) => NamedParameter("character_octet_length", ParameterValue.from(value))
          case ColumnsViewFieldValue.numericPrecision(value) => NamedParameter("numeric_precision", ParameterValue.from(value))
          case ColumnsViewFieldValue.numericPrecisionRadix(value) => NamedParameter("numeric_precision_radix", ParameterValue.from(value))
          case ColumnsViewFieldValue.numericScale(value) => NamedParameter("numeric_scale", ParameterValue.from(value))
          case ColumnsViewFieldValue.datetimePrecision(value) => NamedParameter("datetime_precision", ParameterValue.from(value))
          case ColumnsViewFieldValue.intervalType(value) => NamedParameter("interval_type", ParameterValue.from(value))
          case ColumnsViewFieldValue.intervalPrecision(value) => NamedParameter("interval_precision", ParameterValue.from(value))
          case ColumnsViewFieldValue.characterSetCatalog(value) => NamedParameter("character_set_catalog", ParameterValue.from(value))
          case ColumnsViewFieldValue.characterSetSchema(value) => NamedParameter("character_set_schema", ParameterValue.from(value))
          case ColumnsViewFieldValue.characterSetName(value) => NamedParameter("character_set_name", ParameterValue.from(value))
          case ColumnsViewFieldValue.collationCatalog(value) => NamedParameter("collation_catalog", ParameterValue.from(value))
          case ColumnsViewFieldValue.collationSchema(value) => NamedParameter("collation_schema", ParameterValue.from(value))
          case ColumnsViewFieldValue.collationName(value) => NamedParameter("collation_name", ParameterValue.from(value))
          case ColumnsViewFieldValue.domainCatalog(value) => NamedParameter("domain_catalog", ParameterValue.from(value))
          case ColumnsViewFieldValue.domainSchema(value) => NamedParameter("domain_schema", ParameterValue.from(value))
          case ColumnsViewFieldValue.domainName(value) => NamedParameter("domain_name", ParameterValue.from(value))
          case ColumnsViewFieldValue.udtCatalog(value) => NamedParameter("udt_catalog", ParameterValue.from(value))
          case ColumnsViewFieldValue.udtSchema(value) => NamedParameter("udt_schema", ParameterValue.from(value))
          case ColumnsViewFieldValue.udtName(value) => NamedParameter("udt_name", ParameterValue.from(value))
          case ColumnsViewFieldValue.scopeCatalog(value) => NamedParameter("scope_catalog", ParameterValue.from(value))
          case ColumnsViewFieldValue.scopeSchema(value) => NamedParameter("scope_schema", ParameterValue.from(value))
          case ColumnsViewFieldValue.scopeName(value) => NamedParameter("scope_name", ParameterValue.from(value))
          case ColumnsViewFieldValue.maximumCardinality(value) => NamedParameter("maximum_cardinality", ParameterValue.from(value))
          case ColumnsViewFieldValue.dtdIdentifier(value) => NamedParameter("dtd_identifier", ParameterValue.from(value))
          case ColumnsViewFieldValue.isSelfReferencing(value) => NamedParameter("is_self_referencing", ParameterValue.from(value))
          case ColumnsViewFieldValue.isIdentity(value) => NamedParameter("is_identity", ParameterValue.from(value))
          case ColumnsViewFieldValue.identityGeneration(value) => NamedParameter("identity_generation", ParameterValue.from(value))
          case ColumnsViewFieldValue.identityStart(value) => NamedParameter("identity_start", ParameterValue.from(value))
          case ColumnsViewFieldValue.identityIncrement(value) => NamedParameter("identity_increment", ParameterValue.from(value))
          case ColumnsViewFieldValue.identityMaximum(value) => NamedParameter("identity_maximum", ParameterValue.from(value))
          case ColumnsViewFieldValue.identityMinimum(value) => NamedParameter("identity_minimum", ParameterValue.from(value))
          case ColumnsViewFieldValue.identityCycle(value) => NamedParameter("identity_cycle", ParameterValue.from(value))
          case ColumnsViewFieldValue.isGenerated(value) => NamedParameter("is_generated", ParameterValue.from(value))
          case ColumnsViewFieldValue.generationExpression(value) => NamedParameter("generation_expression", ParameterValue.from(value))
          case ColumnsViewFieldValue.isUpdatable(value) => NamedParameter("is_updatable", ParameterValue.from(value))
        }
        val quote = '"'.toString
        val q = s"""select table_catalog, table_schema, "table_name", "column_name", ordinal_position, column_default, is_nullable, data_type, character_maximum_length, character_octet_length, numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision, "character_set_catalog", "character_set_schema", "character_set_name", "collation_catalog", "collation_schema", "collation_name", domain_catalog, domain_schema, domain_name, udt_catalog, udt_schema, udt_name, "scope_catalog", "scope_schema", "scope_name", maximum_cardinality, dtd_identifier, is_self_referencing, is_identity, identity_generation, identity_start, identity_increment, identity_maximum, identity_minimum, identity_cycle, is_generated, generation_expression, is_updatable
                    from information_schema."columns"
                    where ${namedParams.map(x => s"$quote${x.name}$quote = {${x.name}}").mkString(" AND ")}
                 """
        // this line is here to include an extension method which is only needed for scala 3. no import is emitted for `SQL` to avoid warning for scala 2
        import anorm._
        SQL(q)
          .on(namedParams: _*)
          .as(ColumnsViewRow.rowParser(1).*)
    }
  
  }
}
