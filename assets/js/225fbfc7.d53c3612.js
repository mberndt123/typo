"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[7188],{1450:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=t(4848),d=t(8453);const r={title:"Testing with stubs"},i=void 0,o={id:"other-features/testing-with-stubs",title:"Testing with stubs",description:"It can be incredibly tiring to write tests for the database layer.",source:"@site/docs/other-features/testing-with-stubs.md",sourceDirName:"other-features",slug:"/other-features/testing-with-stubs",permalink:"/typo/docs/other-features/testing-with-stubs",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Testing with stubs"},sidebar:"tutorialSidebar",previous:{title:"User-selected types",permalink:"/typo/docs/type-safety/user-selected-types"},next:{title:"Testing with random values",permalink:"/typo/docs/other-features/testing-with-random-values"}},a={},c=[{value:"DSL",id:"dsl",level:2},{value:"*Note",id:"note",level:3},{value:"An example of a generated <code>RepoMock</code>:",id:"an-example-of-a-generated-repomock",level:2}];function l(e){const s={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,d.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.p,{children:"It can be incredibly tiring to write tests for the database layer."}),"\n",(0,n.jsx)(s.p,{children:"Often you want to split you code in pure/effectful code and just test the pure parts,\nbut sometimes you want to observe mutations in the database as well."}),"\n",(0,n.jsx)(s.p,{children:"Sometimes spinning up a real database for this is the right answer, sometimes it's not.\nIt is always slow, however, so it's way easier to get a fast test suite if you're not doing it."}),"\n",(0,n.jsx)(s.p,{children:"The argument for the approach taken by Typo is that since the interaction between Scala\nand PostgreSQL is guaranteed to be correct*, it is less important to back your tests with a real database."}),"\n",(0,n.jsxs)(s.p,{children:["This leads us to stubs (called mocks in the generated code), implementations of the repository\ninterfaces backed by a mutable ",(0,n.jsx)(s.code,{children:"Map"}),". This can be generated for all tables with a primary key."]}),"\n",(0,n.jsx)(s.h2,{id:"dsl",children:"DSL"}),"\n",(0,n.jsxs)(s.p,{children:["Notable, these mocks work with the ",(0,n.jsx)(s.a,{href:"/typo/docs/what-is/dsl",children:"dsl"}),", which lets you describe semi-complex joins, updates, where predicates,\nstring operations and so on in your code, and test it in-memory!"]}),"\n",(0,n.jsx)(s.h3,{id:"note",children:"*Note"}),"\n",(0,n.jsx)(s.p,{children:"Typo guarantees schema correctness, but you can still break constraints.\nOr your tests need more advanced PostgreSQL functionality."}),"\n",(0,n.jsx)(s.p,{children:"Stubs are obviously not a full replacement, but if they can be used for some non-zero percentage\nof your tests it's still very beneficial!"}),"\n",(0,n.jsxs)(s.h2,{id:"an-example-of-a-generated-repomock",children:["An example of a generated ",(0,n.jsx)(s.code,{children:"RepoMock"}),":"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-scala",children:'import adventureworks.person.address.*\nimport typo.dsl.*\nimport typo.dsl.DeleteBuilder.DeleteBuilderMock\nimport typo.dsl.UpdateBuilder.UpdateBuilderMock\nimport java.sql.Connection\nimport scala.annotation.nowarn\n\nclass AddressRepoMock(toRow: Function1[AddressRowUnsaved, AddressRow],\n                      map: scala.collection.mutable.Map[AddressId, AddressRow] = scala.collection.mutable.Map.empty) extends AddressRepo {\n  override def delete: DeleteBuilder[AddressFields, AddressRow] = {\n    DeleteBuilderMock(DeleteParams.empty, AddressFields.structure.fields, map)\n  }\n  override def deleteById(addressid: AddressId)(implicit c: Connection): Boolean = {\n    map.remove(addressid).isDefined\n  }\n  override def deleteByIds(addressids: Array[AddressId])(implicit c: Connection): Int = {\n    addressids.map(id => map.remove(id)).count(_.isDefined)\n  }\n  override def insert(unsaved: AddressRow)(implicit c: Connection): AddressRow = {\n    val _ = if (map.contains(unsaved.addressid))\n      sys.error(s"id ${unsaved.addressid} already exists")\n    else\n      map.put(unsaved.addressid, unsaved)\n\n    unsaved\n  }\n  override def insert(unsaved: AddressRowUnsaved)(implicit c: Connection): AddressRow = {\n    insert(toRow(unsaved))\n  }\n  override def insertStreaming(unsaved: Iterator[AddressRow], batchSize: Int)(implicit c: Connection): Long = {\n    unsaved.foreach { row =>\n      map += (row.addressid -> row)\n    }\n    unsaved.size.toLong\n  }\n  /* NOTE: this functionality requires PostgreSQL 16 or later! */\n  override def insertUnsavedStreaming(unsaved: Iterator[AddressRowUnsaved], batchSize: Int)(implicit c: Connection): Long = {\n    unsaved.foreach { unsavedRow =>\n      val row = toRow(unsavedRow)\n      map += (row.addressid -> row)\n    }\n    unsaved.size.toLong\n  }\n  override def select: SelectBuilder[AddressFields, AddressRow] = {\n    SelectBuilderMock(AddressFields.structure, () => map.values.toList, SelectParams.empty)\n  }\n  override def selectAll(implicit c: Connection): List[AddressRow] = {\n    map.values.toList\n  }\n  override def selectById(addressid: AddressId)(implicit c: Connection): Option[AddressRow] = {\n    map.get(addressid)\n  }\n  override def selectByIds(addressids: Array[AddressId])(implicit c: Connection): List[AddressRow] = {\n    addressids.flatMap(map.get).toList\n  }\n  override def selectByIdsTracked(addressids: Array[AddressId])(implicit c: Connection): Map[AddressId, Option[AddressRow]] = {\n    val byId = selectByIds(addressids).view.map(x => (x.addressid, x)).toMap\n    addressids.view.map(id => (id, byId.get(id))).toMap\n  }\n  override def update: UpdateBuilder[AddressFields, AddressRow] = {\n    UpdateBuilderMock(UpdateParams.empty, AddressFields.structure.fields, map)\n  }\n  override def update(row: AddressRow)(implicit c: Connection): Boolean = {\n    map.get(row.addressid) match {\n      case Some(`row`) => false\n      case Some(_) =>\n        map.put(row.addressid, row): @nowarn\n        true\n      case None => false\n    }\n  }\n  override def upsert(unsaved: AddressRow)(implicit c: Connection): AddressRow = {\n    map.put(unsaved.addressid, unsaved): @nowarn\n    unsaved\n  }\n}\n\n'})})]})}function p(e={}){const{wrapper:s}={...(0,d.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>i,x:()=>o});var n=t(6540);const d={},r=n.createContext(d);function i(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:i(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);