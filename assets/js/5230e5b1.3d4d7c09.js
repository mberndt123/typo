"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[3913],{3905:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>f});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},s=Object.keys(e);for(a=0;a<s.length;a++)r=s[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)r=s[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var p=a.createContext({}),c=function(e){var t=a.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},l=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,s=e.originalType,p=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),d=c(r),y=n,f=d["".concat(p,".").concat(y)]||d[y]||m[y]||s;return r?a.createElement(f,o(o({ref:t},l),{},{components:r})):a.createElement(f,o({ref:t},l))}));function f(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=r.length,o=new Array(s);o[0]=y;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[d]="string"==typeof e?e:n,o[1]=i;for(var c=2;c<s;c++)o[c]=r[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}y.displayName="MDXCreateElement"},8101:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var a=r(7462),n=(r(7294),r(3905));const s={title:"Date/time types"},o=void 0,i={unversionedId:"type-safety/date-time",id:"type-safety/date-time",title:"Date/time types",description:"Typo uses its own wrapper types for date/time, which delegates to java.time.",source:"@site/docs/type-safety/date-time.md",sourceDirName:"type-safety",slug:"/type-safety/date-time",permalink:"/typo/docs/type-safety/date-time",draft:!1,tags:[],version:"current",frontMatter:{title:"Date/time types"},sidebar:"tutorialSidebar",previous:{title:"Arrays",permalink:"/typo/docs/type-safety/arrays"},next:{title:"Defaulted types",permalink:"/typo/docs/type-safety/defaulted-types"}},p={},c=[],l={toc:c},d="wrapper";function m(e){let{components:t,...r}=e;return(0,n.kt)(d,(0,a.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"Typo uses its own wrapper types for date/time, which delegates to ",(0,n.kt)("inlineCode",{parentName:"p"},"java.time"),"."),(0,n.kt)("p",null,"For ",(0,n.kt)("inlineCode",{parentName:"p"},"timetz"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"OffsetTime")," is used.\nFor ",(0,n.kt)("inlineCode",{parentName:"p"},"timestamptz"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"Instant")," is used, since PostgreSQL store these timestamps in UTC."),(0,n.kt)("p",null,"See ",(0,n.kt)("a",{parentName:"p",href:"/typo/docs/type-safety/typo-types"},"typo-types")," for some motivation for why the wrapper types were necessary."),(0,n.kt)("p",null,"The most important reason was that the PostgreSQL driver loses precision and offsets, and for accuracy it's important to avoid that code path.\nTo that end, values are transferred as strings. You can make use of these data types outside of Typo if cast to ",(0,n.kt)("inlineCode",{parentName:"p"},"::text")," explicitly in sql."),(0,n.kt)("p",null,"With Typo you can round-trip rows with ",(0,n.kt)("inlineCode",{parentName:"p"},"Instant")," and the resulting row will compare equal to the one you inserted."),(0,n.kt)("p",null,"Ref ",(0,n.kt)("a",{parentName:"p",href:"/typo/docs/type-safety/arrays"},"arrays"),", arrays of date/times are usable if you define such a column."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},"import java.time.*\n\n/** This is `java.time.TypoInstant`, but with microsecond precision and transferred to and from postgres as strings. The reason is that postgres driver and db libs are broken */\ncase class TypoInstant(value: Instant)\n/** This is `java.time.LocalDate`, but transferred to and from postgres as strings. The reason is that postgres driver and db libs are broken */\ncase class TypoLocalDate(value: LocalDate)\n/** This is `java.time.LocalDateTime`, but with microsecond precision and transferred to and from postgres as strings. The reason is that postgres driver and db libs are broken */\ncase class TypoLocalDateTime(value: LocalDateTime)\n/** This is `java.time.LocalTime`, but with microsecond precision and transferred to and from postgres as strings. The reason is that postgres driver and db libs are broken */\ncase class TypoLocalTime(value: LocalTime)\n/** This is `java.time.OffsetTime`, but with microsecond precision and transferred to and from postgres as strings. The reason is that postgres driver and db libs are broken */\ncase class TypoOffsetTime(value: OffsetTime)\n")))}m.isMDXComponent=!0}}]);