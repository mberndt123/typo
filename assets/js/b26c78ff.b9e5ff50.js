"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[9795],{1675:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var o=s(4848),n=s(8453);const a={title:"Picking subsets of relations with Selector"},c=void 0,r={id:"customization/selector",title:"Picking subsets of relations with Selector",description:"For much of the customization, you select sets of relations, or enable particular pieces of code generation for a set of relations.",source:"@site/docs/customization/selector.md",sourceDirName:"customization",slug:"/customization/selector",permalink:"/typo/docs/customization/selector",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Picking subsets of relations with Selector"},sidebar:"tutorialSidebar",previous:{title:"Customize column types",permalink:"/typo/docs/customization/customize-types"}},i={},l=[{value:"Pick relations by name or by schema",id:"pick-relations-by-name-or-by-schema",level:2},{value:"Selectors can be inverted",id:"selectors-can-be-inverted",level:3},{value:"Selectors are also composable:",id:"selectors-are-also-composable",level:3}];function m(e){const t={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"For much of the customization, you select sets of relations, or enable particular pieces of code generation for a set of relations."}),"\n",(0,o.jsxs)(t.p,{children:["In order to make this convenient, there is a ",(0,o.jsx)(t.code,{children:"Selector"})," data type."]}),"\n",(0,o.jsx)(t.h2,{id:"pick-relations-by-name-or-by-schema",children:"Pick relations by name or by schema"}),"\n",(0,o.jsxs)(t.p,{children:["You can pick relations by expressing with ",(0,o.jsx)(t.code,{children:"Selector"})," what you want:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:'import typo.*\n\nval personAndPet0 = Selector.fullRelationNames("myschema.person", "myschemapet") // picks exactly these tables\nval personAndPet = Selector.relationNames("person", "pet") // picks these regardless of schema\nval mySchema = Selector.schemas("myschema") // picks all relations in schema\n\n// heaviest syntax, but most flexible\nval custom: Selector = relName => relName.schema.exists(_.contains("foo")) && relName.name.contains("bar")\n\n'})}),"\n",(0,o.jsx)(t.h3,{id:"selectors-can-be-inverted",children:"Selectors can be inverted"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:'!Selector.schemas("myschema") // matches everything except schema "myschema"\n'})}),"\n",(0,o.jsx)(t.h3,{id:"selectors-are-also-composable",children:"Selectors are also composable:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-scala",children:"// picks relations which are called `person` or `pet` AND are in the `myschema` schema\npersonAndPet and mySchema\n\n// picks those who are *both* called `person` or `pet` OR are in the `myschema` schema. \n// This will typically select more relations\npersonAndPet or mySchema \n"})}),"\n",(0,o.jsx)(t.p,{children:"The and/or names follows boolean logic, and may actually be a bit counter-intuitive in this particular context. Suggestions welcome to improve naming"})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>c,x:()=>r});var o=s(6540);const n={},a=o.createContext(n);function c(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:c(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);